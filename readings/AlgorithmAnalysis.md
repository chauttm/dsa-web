Khi làm việc với các chương trình giải quyết các vấn đề khó hoặc xử lý lượng lớn dữ liệu, ta chắc chắn sẽ đặt ra những câu hỏi như thế này:
Chương trình của tôi sẽ mất bao lâu để chạy?
Tại sao chương trình của tôi lại hết bộ nhớ?

Những câu hỏi này quá mơ hồ để có thể trả lời một cách chính xác, các câu trả lời phụ thuộc vào nhiều yếu tố như đặc tính của máy tính cụ thể đang được sử dụng, dữ liệu cụ thể đang được xử lý, và chương trình cụ thể đang thực hiện công việc (thực thi một thuật toán nào đó). Tất cả những yếu tố này để lại cho chúng ta một lượng thông tin khổng lồ cần phân tích.

Bất chấp những thách thức này, cách xây dựng các câu trả lời hữu ích cho những câu hỏi cơ bản này thường khá rõ ràng, như bạn sẽ thấy trong phần này. Quá trình này dựa trên *phương pháp khoa học*, là các kỹ thuật được khoa học chấp nhận rộng rãi để phát triển kiến thức về thế giới tự nhiên. Chúng ta áp dụng *phân tích toán học* để xây dựng các mô hình chi phí ngắn gọn và thực hiện các *nghiên cứu bằng thực nghiệm* để thẩm định các mô hình này.

### Phương pháp khoa học
Chính cách tiếp cận mà các nhà khoa học sử dụng để hiểu thế giới tự nhiên cũng áp dụng được cho việc tìm hiểu về thời gian chạy của các chương trình:
- *Quan sát* một đặc điểm nào đó của thế giới tự nhiên, thường là với các phép đo chính xác.
- *Đưa ra giả thuyết* là một mô hình phù hợp với các quan sát.
- *Dự đoán* các sự kiện bằng cách áp dụng giả thuyết.
- *Xác minh* các dự đoán bằng cách thực hiện các quan sát tiếp theo.
- *Thẩm định* bằng cách lặp lại quá trình cho đến khi giả thuyết khớp với các quan sát.

Một trong những nguyên tắc quan trọng của phương pháp khoa học là các thí nghiệm mà chúng ta thiết kế phải có *khả năng tái lập*, để người khác có thể tự thuyết phục về tính đúng đắn của giả thuyết. Các giả thuyết cũng phải có *khả năng bị phản chứng*, để chúng ta có thể chắc chắn khi xác định một giả thuyết là sai (và do đó cần được sửa đổi). Như một câu nói nổi tiếng được cho là của Einstein ("*Không có số lượng thí nghiệm nào là đủ để có thể chứng minh là tôi đúng; chỉ cần một thí nghiệm là có thể chứng minh tôi sai*"), chúng ta không bao giờ có thể chắc chắn rằng một giả thuyết nào đó là hoàn toàn đúng; chúng ta chỉ có thể thẩm định rằng nó nhất quán với các quan sát của chúng ta.

### Quan sát
Thách thức đầu tiên của chúng ta là quan sát định lượng: làm cách nào để đo thời gian chạy của các chương trình. Nhiệm vụ này dễ dàng hơn nhiều so với các ngành khoa học tự nhiên. Chúng ta không cần phóng tên lửa lên sao Hỏa hay giết động vật thí nghiệm hay phân rã một nguyên tử — chúng ta chỉ cần chạy chương trình. Thật vậy, *mỗi* khi bạn chạy một chương trình, bạn đang thực hiện một thí nghiệm khoa học, mà trong đó chương trình của bạn là thế giới tự nhiên, để trả lời một trong những câu hỏi cốt lõi của chúng ta: *Chương trình của tôi sẽ chạy mất bao lâu?*

Quan sát định tính đầu tiên của chúng ta về hầu hết các chương trình là: *kích thước bài toán* là một đặc trưng cho độ khó của nhiệm vụ tính toán. Thông thường, kích thước bài toán là kích thước của đầu vào hoặc giá trị của một đối số dòng lệnh. Theo trực giác, thời gian chạy sẽ tăng theo kích thước bài toán, nhưng "nó tăng *bao nhiêu*" mới là câu hỏi xuất hiện một cách tự nhiên mỗi khi chúng ta phát triển và chạy một chương trình.

Một quan sát định tính khác đối với nhiều chương trình là: thời gian chạy nói chung là không bị ảnh hưởng bởi nội dung đầu vào; nó phụ thuộc vào kích thước bài toán là chính. Nếu quan sát này không đúng, chúng ta cần thực hiện các bước để hiểu rõ hơn và có lẽ kiểm soát tốt hơn độ nhạy của thời gian chạy đối với đầu vào. Nhưng điều này thường đúng, vì vậy bây giờ chúng ta tập trung vào mục tiêu định lượng tốt hơn mối quan hệ giữa kích thước bài toán và thời gian chạy.

***Ví dụ.*** Ta sẽ dùng chương trình `ThreeSum` đưới đây làm ví dụ để thảo luận. Chương trình này đọc một file chứa N số nguyên và đếm xem có bao nhiêu bộ ba trong đó có tổng bằng 0 (giả sử rằng không có tràn số). Công việc tính toán này có vẻ nhàm chán đối với bạn, nhưng nó liên quan rất sâu đến nhiều tác vụ tính toán mang tính nền tảng (ví dụ, xem Bài tập 1.4.26). Để làm dữ liệu thí nghiệm, hãy lấy file `1Mints.txt` từ trang web của sách, file này chứa 1 triệu giá trị int được tạo ngẫu nhiên. Các số thứ hai, thứ tám và thứ mười trong `1Mints.txt` có tổng bằng 0. Hỏi ngoài ra còn có bao nhiêu bộ ba như vậy trong tệp? Chương trình ThreeSum có thể cho chúng ta câu trả lời, nhưng liệu nó có thể làm vậy trong một khoảng thời gian hợp lý không? Kích thước bài toán N có quan hệ như thế nào với thời gian chạy của ThreeSum? Ở thí nghiệm đầu tiên, hãy chạy ThreeSum trên máy của bạn cho các file `1Kints.txt`, `2Kints.txt`, `4Kints.txt`, và `8Kints.txt`, chúng lần lượt chứa 1000, 2000, 4000, và 8000 số đầu tiên của `1Mints.txt`. Bạn có thể nhanh chóng thấy kết quả rằng có 70 bộ ba có tổng bằng 0 trong tệp `1Kints.txt` và có 528 bộ ba có tổng bằng 0 trong tệp `2Kints.txt`. Chương trình mất nhiều thời gian hơn đáng kể để xác định có 4.039 bộ ba có tổng bằng 0 trong tệp `4Kints.txt`, và khi bạn chờ chương trình hoàn thành cho tệp `8Kints.txt`, bạn sẽ thấy mình tự đặt câu hỏi: *Chương trình sẽ chạy mất bao lâu?* Như bạn sẽ thấy, trả lời câu hỏi này cho chương trình này hóa ra lại dễ dàng. Thật vậy, thường là bạn có thể đưa ra một dự đoán khá chính xác ngay trong khi chương trình đang chạy.

***Stopwatch.*** Việc đo thời gian chạy của một chương trình một cách chính xác và đáng tin cậy có thể khó khăn. May mắn là chúng ta thường hài lòng với các ước tính. Chúng ta muốn có thể phân biệt các chương trình sẽ hoàn thành trong vài giây hoặc vài phút với những chương trình có thể yêu cầu vài ngày hoặc vài tháng hoặc hơn. Khi có một chương trình nhanh gấp đôi một chương trình khác khi thực hiện cùng một tác vụ, chúng ta muốn biết được điều đó. Tuy nhiên, chúng ta vẫn cần các phép đo chính xác để tạo ra dữ liệu thực nghiệm mà chúng ta có thể sử dụng để thiết lập các giả thuyết về mối quan hệ giữa thời gian chạy với kích thước bài toán và kiểm tra tính đúng đắn của các giả thuyết đó. Với mục đích này, chúng ta sử dụng cấu trúc `Stopwatch`. Phương thức `elapsedTime()` của nó trả về thời gian (tính bằng giây) đã trôi qua kể từ khi nó được tạo. Phương thức này dùng hàm hệ thống `currentTimeMillis()` của Java, hàm này trả về thời gian hiện tại tính bằng miligiây, để lưu thời gian khi constructor của nó được gọi, sau đó gọi lại lần nữa để tính thời gian đã trôi qua khi `elapsedTime()` được gọi.

![Stopwatch API](https://algs4.cs.princeton.edu/14analysis/images/stopwatch-api.png "Stopwatch API")

***Phân tích dữ liệu thực nghiệm.*** Chương trình `DoublingTest` là một chương trình ứng dụng sử dụng `Stopwatch` một cách tinh vi hơn để tạo ra dữ liệu thực nghiệm cho `ThreeSum`. Nó tạo ra một chuỗi các mảng đầu vào ngẫu nhiên, mỗi bước lại tăng gấp đôi kích thước mảng, và in ra thời gian chạy của `ThreeSum.count()` cho mỗi kích thước đầu vào. Các thí nghiệm này chắc chắn có thể tái lập được — bạn cũng có thể chạy chúng trên máy tính của mình, bao nhiêu lần tùy thích. Khi bạn chạy `DoublingTest`, bạn sẽ thấy bản thân thực hiện một chu trình dự đoán-kiểm chứng: nó in ra vài dòng rất nhanh, nhưng sau đó chậm lại đáng kể. Mỗi khi nó in ra một dòng, bạn sẽ tự hỏi bao lâu nữa thì nó sẽ in dòng tiếp theo. Tất nhiên, vì máy tính của bạn khác với máy của chúng tôi, thời gian chạy thực tế mà bạn nhận được có thể sẽ khác với thời gian hiển thị trên máy tính của chúng tôi. Thật vậy, nếu máy tính của bạn nhanh gấp đôi máy của chúng tôi, thời gian chạy của bạn sẽ chỉ bằng khoảng một nửa của chúng tôi, điều này ngay lập tức dẫn đến giả thuyết có cơ sở vững chắc rằng thời gian chạy trên các máy tính khác nhau có thể khác nhau bởi một hệ số là hằng số. Tuy nhiên, bạn vẫn sẽ thấy mình đặt câu hỏi chi tiết hơn: *Chương trình của tôi sẽ chạy với thời gian là bao lâu, tính theo một hàm của kích thước đầu vào?* Để giúp trả lời câu hỏi này, chúng ta vẽ đồ thị dữ liệu. Các đồ thị dưới đây hiển thị kết quả trên hệ tọa độ thông thường và hệ log-log, với kích thước bài toán N trên trục x và thời gian chạy T(N) trên trục y. Đồ thị log-log cho thấy ngay một giả thuyết về thời gian chạy: dữ liệu khớp với một đường thẳng có độ dốc 3 trên đồ thị log-log. Phương trình của đường thẳng đó là
$$lg(T(N)) = 3 lg N + lg a$$
trong đó, `a` là một hằng số. Phương trình trên tương đương với
$$T(N) = a N^3$$
đó là hàm của thời gian chạy với biến là kích thước đầu vào, cái mà ta đang cần. Chúng ta có thể sử dụng một trong các điểm dữ liệu của mình để giải phương trình tìm a — ví dụ, $T(8000) = 51.1 = a 8000^3$, vậy $a = 9.98 * 10^(-11)$ — và sau đó sử dụng phương trình
$$T(N) = 9.98 * 10^-11 N^3$$
để dự đoán thời gian chạy cho N lớn. Một cách không chính thức, chúng ta đang kiểm chứng giả thuyết rằng các điểm dữ liệu trên biểu đồ log-log nằm gần đường thẳng này. Có thể dùng các phương pháp thống kê để phân tích cẩn thận hơn nhằm ước tính `a` và số mũ `b`, nhưng các phép tính nhanh của chúng ta đủ để ước tính thời gian chạy cho hầu hết các mục đích. Ví dụ, có thể ước tính thời gian chạy trên máy tính của chúng tôi  cho `N = 16.000` là khoảng $9.98 * 10^-11 * 16000^3 = 408.8$ giây, hay là khoảng 6.8 phút (thời gian thực tế là 409.3 giây). Trong khi chờ máy tính của bạn in dòng cho `N = 16.000` trong `DoublingTest`, bạn có thể sử dụng phương pháp này để dự đoán khi nào nó sẽ kết thúc, sau đó kiểm tra kết quả bằng cách chờ xem liệu dự đoán của bạn có đúng không.